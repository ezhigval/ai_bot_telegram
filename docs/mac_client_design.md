## Дизайн-док macOS‑клиента (`mac_client/`)

Этот документ описывает архитектуру, экраны и состояние нативного macOS‑клиента для персонального ИИ.
Клиент реализуется на **Swift/SwiftUI**, не содержит собственной ИИ‑логики и общается с ядром `core/`
по HTTP/WebSocket API.

---

### 1. Цели и принципы

- **Единый пользовательский профиль**: клиент работает с `user_name`, который мапится на тот же профиль,
  что и у Telegram‑бота.
- **Тонкий клиент**: вся ИИ‑логика и память живут в `core/`; macOS‑клиент отвечает за UX, локальный кеш и интеграцию с системой.
- **Гибкость развёртывания**: ядро может быть локальным или удалённым сервером, клиент использует только `CORE_BASE_URL`
  из конфигурации (без хардкода адресов).
- **Современный UX**: быстрый чат, поиск по истории, работа с файлами/медиа, устойчивость к сетевым ошибкам.

---

### 2. Высокоуровневая архитектура клиента

Паттерн: **MVVM + централизованный стор состояния** (упрощённая Redux‑подобная модель).

- **UI‑слой (SwiftUI)**:
  - `App` и `Scene` (запуск, окна);
  - экраны: экран выбора профиля/логина, главный экран чата, экран истории/поиска, экран файлов/медиа, настройки.
- **Слой состояния (Store)**:
  - единое приложение состояния `AppState`;
  - действия `AppAction` и редьюсер/обработчик;
  - `AppStore` как ObservableObject для SwiftUI.
- **Сетевой слой (CoreAPI)**:
  - абстракция `CoreClient` с методами:
    - `sendMessage(...)` → `POST /v1/messages`;
    - `loadHistory(...)` → `GET /v1/history`;
    - `loadProfile(...)` / `updateProfile(...)` → `GET/PATCH /v1/profile`;
  - конфигурация базового URL ядра (`CoreConfig`), чтение из настроек/окружения.
- **Модели данных**:
  - DTO для обмена с ядром (соответствие форматам из `docs/architecture.md`);
  - внутренние модели UI (сообщения, диалоги, пользовательский профиль, файлы/медиа).
- **Локальный кеш** (позже будет детализирован отдельной задачей):
  - кеш последних диалогов и сообщений;
  - базовая оффлайн‑поддержка и быстрый старт приложения.

---

### 3. Экраны и UX‑потоки

#### 3.1. Экран выбора пользователя / логин по `user_name`

**Цель**: однозначно идентифицировать пользователя и связать его с профилем в ядре.

- Поле ввода `user_name`.
- Кнопка «Продолжить»:
  - при нажатии — запрос в ядро `GET /v1/profile?user_name=...`;
  - если профиль существует — загрузка настроек и переход в главный экран чата;
  - если профиль не существует — создание нового (через `PATCH /v1/profile` или отдельный endpoint, когда появится в ядре).
- Возможность сменить `user_name` в настройках.

#### 3.2. Главный экран чата

**Цель**: основной интерфейс общения с ИИ.

- Список сообщений (история текущего диалога):
  - сообщения пользователя и агента;
  - индикаторы статуса (отправляется, ошибка, доставлено).
- Поле ввода текста + кнопка отправки.
- Кнопка прикрепления файла/медиа:
  - выбор файла из Finder;
  - отображение прикреплённого файла в UI до отправки;
  - передача файла в ядро через `POST /v1/messages`.
- Индикатор активности агента (тайпинг, «думает» и т.п.).
- Верхняя панель:
  - выбор диалога / контекста (если реализуем несколько сессий);
  - доступ к настройкам и истории.

#### 3.3. Экран истории и поиска

**Цель**: просмотр прошлых диалогов и быстрый поиск по истории.

- Список диалогов:
  - название/превью (первые фразы);
  - дата последней активности.
- Поле поиска:
  - запрос на `GET /v1/history?query=...` (конкретный формат будет уточнён в `docs/architecture.md`);
  - отображение результатов фильтрации/поиска.
- При выборе диалога — переход к соответствующему чату.

#### 3.4. Экран файлов и медиа

**Цель**: управлять файлами и медиа, которые связаны с профилем пользователя.

- Список файлов/медиа, доступных в профиле:
  - название, тип, размер, дата загрузки;
  - принадлежность к диалогам/контекстам (по мере реализации на стороне ядра).
- Действия:
  - открыть/предпросмотр (встроенный или через системные средства);
  - отправить файл в текущий диалог;
  - удалить/отвязать файл (если это будет поддержано ядром).

#### 3.5. Экран настроек

**Цель**: управление профилем и поведением клиента.

- `user_name` (с возможностью смены).
- Настройки профиля, полученные из ядра:
  - язык и тон общения;
  - предпочтения по формату ответов (коротко/подробно, текст/голос и т.п.).
- Технические настройки:
  - `CORE_BASE_URL` (опционально для локальной отладки, с предупреждением);
  - флаг «работать только локально» и др. (по мере развития ядра).

---

### 4. Состояние приложения (AppState)

Единое состояние приложения делится на логические подсостояния:

- `SessionState`:
  - текущий `user_name`;
  - статус аутентификации/инициализации профиля;
  - текущий профиль пользователя (настройки).
- `ChatState`:
  - список сообщений текущего диалога;
  - статус отправки (idle/sending/error);
  - выбранный диалог/контекст;
  - временно прикреплённые файлы/медиа.
- `HistoryState`:
  - список диалогов;
  - текущий поисковый запрос;
  - результаты поиска;
  - статус загрузки.
- `FilesState`:
  - список файлов/медиа, связанных с профилем;
  - выбранный файл;
  - статус операций (загрузка/удаление/отправка).
- `SettingsState`:
  - локальные настройки клиента (тема, поведение UI и т.п.);
  - сетевой конфиг (`CORE_BASE_URL` и др., если изменяемы из UI).

Состояние обновляется через набор действий (`AppAction`), обрабатываемых редьюсером/методами `AppStore`.

---

### 5. Взаимодействие с ядром (`core/`)

#### 5.1. Базовая конфигурация

- Конфигурация `CoreConfig`:
  - `baseURL` — базовый URL ядра (`http://localhost:PORT` или удалённый сервер);
  - таймауты и политика ретраев;
  - включение/выключение WebSocket‑подключения, если оно будет использоваться.
- Источники конфигурации:
  - значения по умолчанию для локальной разработки;
  - пользовательские переопределения (только при явном согласии пользователя).

#### 5.2. Основные методы API‑клиента

- `sendMessage(userName, content, attachments, contextId?)`:
  - `POST /v1/messages`;
  - тело запроса включает идентификатор пользователя, текст и метаданные по файлам/медиа;
  - ответ — сообщение(я) агента, возможные ссылки на созданные ресурсы.
- `loadHistory(userName, query?, pagination?)`:
  - `GET /v1/history`;
  - поддержка фильтрации/поиска и пагинации (формат будет уточнён в архитектуре ядра).
- `loadProfile(userName)`:
  - `GET /v1/profile`;
  - получение настроек профиля.
- `updateProfile(userName, patch)`:
  - `PATCH /v1/profile`;
  - обновление пользовательских настроек.

#### 5.3. Обработка ошибок и устойчивость

- Обертка над сетевыми вызовами:
  - единый тип ошибок (`CoreError`) с категориями (сетевые, серверные, валидация, неожиданное поведение);
  - маппинг ошибок в понятные пользователю сообщения и состояния UI.
- Поведение при потере связи:
  - отображение баннера/индикатора «Нет соединения с ядром»;
  - возможность повторной отправки неудачных сообщений;
  - сохранение черновиков сообщений локально до успешной отправки.

---

### 6. Локальный кеш и оффлайн‑поддержка (черновой дизайн)

Подробный протокол кеша будет описан в отдельной задаче (`(Agent MacClient) Спроектировать протокол хранения локального кеша диалогов...`),
здесь фиксируется базовое направление:

- Хранить локально:
  - последние диалоги и сообщения для быстрого открытия приложения;
  - минимальный набор профиля пользователя (чтобы не требовать повторного ввода `user_name` и настроек при старте).
- Поток:
  - при старте приложения — загрузка состояния из кеша + параллельная синхронизация с ядром;
  - при успешной синхронизации — обновление кеша.
- Технологии:
  - на первом этапе — `UserDefaults` + локальные файлы/папка приложения;
  - при усложнении — переход на Core Data/SQLite.

---

### 7. Точки расширения и дальнейшая эволюция

- Добавление поддержки голоса:
  - запись и отправка голосовых сообщений в ядро;
  - получение и воспроизведение голосовых ответов (если поддерживается ядром).
- Расширение работы с файлами/медиа:
  - drag&drop из Finder и других приложений;
  - более продвинутый предпросмотр (Quick Look, встроенные вьюеры).
- Интеграция с системными возможностями macOS:
  - глобальное меню/быстрый доступ;
  - шорткаты клавиатуры;
  - возможная интеграция с меню‑баром.

Документ может дополняться и уточняться по мере развития `docs/architecture.md` и протокола API ядра.


