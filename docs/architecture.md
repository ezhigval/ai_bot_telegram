## Архитектура проекта

### Верхнеуровневая схема

- **`cmd/bot`**: точка входа, запуск Telegram-бота, инициализация зависимостей.
- **`internal/telegram`**: слой интеграции с Telegram API:
  - подключение к Telegram Bot API;
  - получение апдейтов (лонг-поллинг);
  - маршрутизация событий (текст, голос, файлы);
  - адаптер между Telegram и ИИ-агентом.
- **`internal/agent`** (будет создан):
  - ядро ИИ-агента;
  - интерфейсы для LLM, памяти, инструментов (веб-поиск, работа с файлами и мультимедиа);
  - логика обучения на взаимодействиях.
- **`internal/storage`** (будет создан):
  - локальное хранение диалогов и пользовательских данных (SQLite/файлы).
- **`internal/tools`** (будет создан):
  - веб-поиск (через бесплатные API);
  - обработка изображений/видео/аудио (через локальные утилиты/библиотеки).

### Каркас ИИ-агента (первый шаг)

Идея — сделать **плагинную систему**, где:

- **`LLMClient`** — интерфейс для любого движка (локальная модель, внешнее бесплатное API и т.д.).
- **`Memory`** — интерфейс для работы с контекстом и историей диалогов.
- **`Tool`** — интерфейс для инструментов (веб-поиск, анализ файлов, мультимедиа).

Это позволит:

- начинать с простого/условно-бесплатного решения (например, локальная модель или free-tier API);
- позже безболезненно заменить движок на более мощный, не меняя остальной код.

### Обучение на взаимодействиях

- Логируем все диалоги локально:
  - пользовательский ID (анонимизированный, если потребуется),
  - запросы/ответы,
  - метаданные (тип сообщения: текст, голос, файл и т.д.).
- На основе истории:
  - строим «навыки» (часто повторяющиеся паттерны запросов/ответов);
  - даём агенту доступ к этой памяти при генерации ответов.

Технически это будет реализовано в виде:

- отдельного слоя `Memory` (например, SQLite + простые векторные индексы);
- фоновых задач для переработки истории в более компактные знания.


